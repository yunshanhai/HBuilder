<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Book Editor</title>
  </head>
  <body>
    <div id="divBook" style="margin: 0 auto; border: solid 1px black;"></div>
    <script src="../d3/js/d3.v3.js"></script>
    <script src="../d3/js/common.js"></script>
    <script src="../js/vue.js"></script>
    <script>
      var client = {
        maxheight: 800
      };

      d3.json('/HBuilder/book/json/book.json', function(data) {
        cl(data);
        initBook(data)
      });

      var book;
      var page;
      var pages;
      var currentPage; //当前页面,暂时未用到
      var currentElement;
      var shapePointIds = d3.set(['topPoint', 'rightPoint', 'bottomPoint', 'leftPoint']);
      var dragPointIds = d3.set(['tlDrag', 'trDrag', 'blDrag', 'brDrag']);
      var lockShape = '';

      function initBook(data) {
        book = data;
        page = book.page;
        pages = d3.map(data.pages);


        book.width = mm2px(book._width);
        book.height = mm2px(book._height);
        page.padding = {
          top: mm2px(page._padding.top),
          right: mm2px(page._padding.right),
          bottom: mm2px(page._padding.bottom),
          left: mm2px(page._padding.left)
        };
        //页面除去padding之后的上下左右
        page.top = page.padding.top;
        page.right = book.width - page.padding.right;
        page.bottom = book.height - page.padding.bottom;
        page.left = page.padding.left;

        cl(book);

        var pageContainer = getPageContainerSize();

        var divBook = d3.select('#divBook')
          .style('width', pageContainer.width + 'px')
          .style('height', pageContainer.height + 'px');

        var pageRootSvg = divBook.append('svg').datum(book.pages[0])
          .attr('width', pageContainer.width)
          .attr('height', pageContainer.height)
          .attr('viewBox', '0 0 ' + book.width + ' ' + book.height);

        initPage(pageRootSvg, book.pages[0]);
        
        pageRootSvg.on('click', function(d){
          cl('svg click');

          if(lockShape){
            removeShapePointsAndDragLevel(pageRootSvg);
            lockShape = '';
          }
        });
      }
      
      function removeShapePointsAndDragLevel(pageRootSvg){
        shapePointIds.forEach(function(value){
          pageRootSvg.select('#' + value + 'Lock').remove();
        });
        
        pageRootSvg.select('#dragLevel').remove();
        
        dragPointIds.forEach(function(value){
          pageRootSvg.select('#' + value).remove();
        })
      }

      function initPage(pageRootSvg, pageData) {

        var defs = pageRootSvg.append('defs');

        //初始化padding框
        var points = [
          [page.left, page.top],
          [page.right, page.top],
          [page.right, page.bottom],
          [page.left, page.bottom]
        ];
        var line = d3.svg.line()
          .x(function(d) {
            return d[0];
          })
          .y(function(d) {
            return d[1];
          })
          .interpolate('linear-closed');
        pageRootSvg.append('path')
          .attr('d', line(points))
          .attr('stroke', 'black')
          .attr('stroke-width', 1)
          .attr('fill', 'none')
          .attr('stroke-dasharray', '5,5');

        //初始化页面元素
        for (var i = 0; i < pageData.elements.length; i++) {
          // console.log(element);
          initElement(pageRootSvg, defs, pageData.elements[i], i);
        }
      }

      function addShapePoint(pageRootSvg, points, id) {
        pageRootSvg.append('circle').attr('id', id)
          .attr('r', 5)
          .attr('cx', points[0])
          .attr('cy', points[1])
          .style('display', 'block')
          .style('stroke', 'red')
          .style('stroke-width', 2)
          .style('fill', 'none');
      }

      function initElement(pageRootSvg, defs, element, index) {
        var shape = pageRootSvg.select('#element' + index);
        if (shape.empty()) {
          shape = pageRootSvg.append(element.shape)
            .attr('id', 'element' + index);
        }
        shape.datum(element);

        //计算形状的八个坐标点
        calcShapePoints(element);

        Object.keys(element.properties).forEach(function(key) {
          shape.attr(key, element.properties[key]);
        });

        Object.keys(element.styles).forEach(function(key) {
          shape.style(key, element.styles[key]);
        });
        
        shape.on('mouseover', function(d, i) {
          cl('shape mouseover');
          if(lockShape === d3.select(this).attr('id') || shapePointIds.has(d3.event.relatedTarget.id)){
            return;
          }
          //初始化元素选择指示点
          addShapePoint(pageRootSvg, d.points.top, 'topPoint', d.points.top);
          addShapePoint(pageRootSvg, d.points.right, 'rightPoint');
          addShapePoint(pageRootSvg, d.points.bottom, 'bottomPoint');
          addShapePoint(pageRootSvg, d.points.left, 'leftPoint');
        })
        .on('mouseout', function(d){
          cl('shape mouseout');
          cl(d.event);
          if(lockShape === d3.select(this).attr('id') || shapePointIds.has(d3.event.relatedTarget.id)){
            return;
          }
          //移除元素选择点
          shapePointIds.forEach(function(value){
            pageRootSvg.select('#' + value).remove();
          });
        })
        .on('click', function(d){
          cl('shape click')
          event.cancelBubble = true;
          
          if(lockShape){
            removeShapePointsAndDragLevel(pageRootSvg);
          }
          
          lockShape = d3.select(this).attr('id');
          
          pageRootSvg.select('#topPoint').attr('id', 'topPointLock');
          pageRootSvg.select('#rightPoint').attr('id', 'rightPointLock');
          pageRootSvg.select('#bottomPoint').attr('id', 'bottomPointLock');
          pageRootSvg.select('#leftPoint').attr('id', 'leftPointLock');
          
          pageRootSvg.append('rect').attr('id', 'dragLevel')
            .attr('x', d.points.tl[0])
            .attr('y', d.points.tl[1])
            .attr('width', d.points.tr[0] - d.points.tl[0])
            .attr('height', d.points.bl[1] - d.points.tl[1])
            .style('stroke', '#8b3838')
            .style('stroke-width', 1)
            .style('fill', 'white')
            .style('fill-opacity', 0)
            .on('click', function(){
              event.cancelBubble = true;
            });
          cl(d.points.tl);
          addDragPoint(pageRootSvg, d.points.tl, 'tlDrag');
          addDragPoint(pageRootSvg, d.points.tr, 'trDrag');
          addDragPoint(pageRootSvg, d.points.bl, 'blDrag');
          addDragPoint(pageRootSvg, d.points.br, 'brDrag');
          
        });
      }
      
      function addDragPoint(pageRootSvg, point, id){
        var square = calcSquareFromCenterPoint(point, 10);
        cl(square);
        var dragPoint = pageRootSvg.append('rect').attr('id', id)
          .attr('x', square.x)
          .attr('y', square.y)
          .attr('width', square.width)
          .attr('height', square.height)
          .style('display', 'block')
          .style('stroke', 'red')
          .style('stroke-width', 2)
          .style('fill', 'white');
        switch(id){
          case 'tlDrag':
            dragPoint.style('cursor', 'nw-resize');
            break;
          case 'trDrag':
            dragPoint.style('cursor', 'ne-resize');
            break;
          case 'blDrag':
            dragPoint.style('cursor', 'sw-resize');
            break;
          case 'brDrag':
            dragPoint.style('cursor', 'se-resize');
            break;
        }
      }
      
      function calcSquareFromCenterPoint(point, width){
        cl(point);
        return {
          x: point[0] - width / 2,
          y: point[1] - width / 2,
          width: width,
          height: width
        };
      }

      /**
       * 计算元素图形的关键点坐标，放到element.points属性
       * center top right bottom left tl tr bl br
       * @param {Object} element 要计算的元素图形
       */
      function calcShapePoints(element) {
        if (!element.hasOwnProperty('points')) {
          element.points = {};
        }
        switch (element.shape) {
          case 'rect':
            element.points.top = [element.properties.x + element.properties.width / 2, element.properties.y];
            element.points.right = [element.properties.x + element.properties.width, element.properties.y + element.properties.height / 2];
            element.points.bottom = [element.properties.x + element.properties.width / 2, element.properties.y + element.properties.height];
            element.points.left = [element.properties.x, element.properties.y + element.properties.height / 2];
            element.points.tl = [element.properties.x, element.properties.y];
            element.points.tr = [element.properties.x + element.properties.width, element.properties.y];
            element.points.bl = [element.properties.x, element.properties.y + element.properties.height];
            element.points.br = [element.properties.x + element.properties.width, element.properties.y + element.properties.height];
            element.points.center = [element.properties.x + element.properties.width / 2, element.properties.y + element.properties.height / 2];
            break;
          case 'circle':
            element.points.top = [element.properties.cx, element.properties.cy - element.properties.r];
            element.points.right = [element.properties.cx + element.properties.r, element.properties.cy];
            element.points.bottom = [element.properties.cx, element.properties.cy + element.properties.r];
            element.points.left = [element.properties.cx - element.properties.r, element.properties.cy];
            element.points.tl = [element.properties.cx - element.properties.r, element.properties.cy - element.properties.r];
            element.points.tr = [element.properties.cx + element.properties.r, element.properties.cy - element.properties.r];
            element.points.bl = [element.properties.cx - element.properties.r, element.properties.cy + element.properties.r];
            element.points.br = [element.properties.cx + element.properties.r, element.properties.cy + element.properties.r];
            element.points.center = [element.properties.cx, element.properties.cy];
            break;
          default:
        }
      }

      function getPageContainerSize() {
        var container = {
          width: 600,
          height: 600 * book.height / book.width
        };
        return container;
      }
    </script>
  </body>
</html>
